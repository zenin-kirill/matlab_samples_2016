%Программа имитационного моделирования алгоритма обработки данных ЧСС

clear all;
close all;
clc;

%% Основные параметры сигнала

mem = 190;        % Данные, измеренные в предыдущем цикле измерений
fr  = 200;        % Частота сердечных сокращений, уд/мин
A   = 1250;      % Амплитуда сигнала, усл. ед.
phi = 0;         % Фаза сигнала, рад.
t   = 6;        % Время наблюдения, сек.
fd  = 40;        % Частотца дискретизации сигнала, Гц
np  = 0;         % Количество помех, накладываемых на сигнал

f   = fr / 60;      % Перевод частоты в герцы 
Tf  = 1/f;          % Период полезных колебаний
NTf = fix(t/Tf);    % Полных перодов за 
Td = 1/fd;          % Период дискретизации
NT = fix(t / Td);   % Количество целых периодов дискретизации за время t
tn = Td * (0 : NT); % Вектор времени (сек), дискретизированный
                    % в соответствии с частотой дисретизации

%% Различные методы моделирования реального сигнала ЧСС

% Вектор значений сигнала чистой синусоиды (имитация сердечных сокращений)
%yn = (A*sin(2*pi*f*tn+phi))+ (A * 1.5);  

% Вектор значений сигнала наложенных синусоид (имитация сердечных сокращений
% и процесса дыхания)
yn = (A*sin(2*pi*f*tn+phi))+ (A * 1.5) + (A/5*sin(2*pi*(f+2)*tn+phi));

% Алгоритм, добавляющий в приближенный сигнал случайным образом
% множество "артефактов" различного характера и длительности
% (имитация процесса измерений в экстримальных условиях)
for i=1:1:np
    n = 5 + randi(NT-5);               % выбор случайного момента времени 
    d = (rand - 0.5) * randi(20000);   % генерация хаарктера и величины помехи
    yn(n) = yn(n) + d;                 % добавление помехи точку
    if (round(rand))                   % генерация длительности помехи 
        yn(n-1) = yn(n-1) + (rand * d);
        if (round(rand))
            yn(n-2) = yn(n-2) + (rand * d);
            if (round(rand))
                yn(n-3) = yn(n-3) + (rand * d/2);
                yn(n-4) = yn(n-4) + (rand * d/2);
            end
        end
    end
    if (round(rand))                   % генерация длительности помехи
        yn(n+1) = yn(n+1) + (rand * d);
        if (round(rand))
            yn(n+2) = yn(n+2) + (rand * d);
            if (round(rand))
                yn(n+3) = yn(n+3) + (rand * d/2);
                yn(n+4) = yn(n+4) + (rand * d/2);
            end
        end
    end
    
end

k = size(yn);      % Длина реализацияя

figure(1);         % Построение графика прилиженного сигнала
hold on;
plot(tn,yn,'k-');
title('Приближенный сигнал ЧСС, под влиянием помех');
xlabel('Время, с.');
ylabel('Сигнал');
axis([0 t 0 4096]);

figure(2);         % Построение графика разбора хар. точек
hold on;
title('Разбор сигнала, поиск минимумов');
xlabel('Время, с.');
ylabel('Сигнал');
plot(tn,yn,'k-');
axis([0 t 0 4096]);

%% Разбор характерных точек

n = 100;     % Размер окна
Nmins = 0;  % Счетчик минимумов

nFirst = 0 + 1; % Начало окна
nLast = 0 + 1;  % Конец окна

mins(:,1) = 0;  % Двумерный массив минимумов
mins(:,2) = 0;  % 1 - минмумы, 2 - номера значений

while (nLast ~= k(2)) % Пока не кончится реализация
    nLast = nFirst + n;
    if (nLast > k(2))
        nLast = k(2);
    end
        
    SA = 0; % Поиск среднего арифметического
    for (i = nFirst:1:nLast) 
       SA = SA + yn(i); 
    end
    SA = SA / (nLast - nFirst);
    
    % Построение линий изобажающие грааницы окна и значения СА
    line([nFirst*Td nFirst*Td],[0 4096],'color', [0,0,1]);
    line([nLast*Td nLast*Td],[0 4096],'color', [0,1,0]);
    line([nFirst*Td nLast*Td],[SA SA],'color', [rand,0,rand]);
    
    for (i = nFirst+5:1:nLast-5)
       if (yn(i) < SA) % Поиск минимумов
           if ((yn(i) < yn(i+1)) && (yn(i) <= yn(i-1))) 
               if ((yn(i) < yn(i+3)) && (yn(i) <= yn(i-3)))
                   if ((yn(i) < yn(i+5)) && (yn(i) <= yn(i-5)))
                        Nmins = Nmins + 1;
                        mins(Nmins,1) = yn(i);
                        mins(Nmins,2) = (i-1) * Td;
                        nNow = i+1;
                   end
               end
           end
       end
    end
    nFirst = nNow;
end

% Отрисовка маркеров минимумов
plot(mins(:,2), mins(:,1),'r*');

Nper = Nmins-1;

% Нахождение значений периода
for i = 1:1:Nper
    periods(i,1) = mins(i+1,2) - mins(i,2);
end

%% Выбор наиболее вероятного периода

hn = 10; % Количество интервалов
hs(:,1) = linspace(0, 0, hn); % Количество величин
hs(:,2) = linspace(0, 0, hn); % в каждом интервале

TDown = min(periods(:,1));  % Нижняя граница значений периодов
TUp = max(periods(:,1));    % Верхняя граница значений периодов

h = (TUp - TDown) / hn;     % Размер интервала

for (i = 1:1:Nper)          % Распределение значений периодов по
    for (j = 1:1:hn)        % интервалам
        if (periods(i,1) < (TDown + (j*h)))
            hs(j,1) = hs(j,1) + 1;
            periods(i,2) = j;
            break
        end
    end
end


ok = 1;
while (ok ~= 0)

maxHS = 1;
for (i = 1:1:hn) % Выбор интервала с наибольшим количеством значений
    if (hs(maxHS,2) == 1)
        if (hs(i,2) == 0)
            maxHS = i;
        end
    else
    if (hs(i,1) > hs(maxHS,1) && hs(i,2)==0)
        maxHS = i;
    end
    end
end

SA = 0;
n0 = 0;

for (i = 1:1:Nper) % Усреднение
    if (periods(i,2) == maxHS)
        n0 = n0 + 1;
        SA = SA + periods(i,1);
    end
end
SA = SA / n0;
ansv = (1/SA)*60;   % Расчет и валидация результата
if ((ansv > 220) || (ansv < 20) || (abs(ansv-mem)>= (mem/4)))
    ok = 1;             % Если значение неправдоподобно
    hs(maxHS,2) = 1;    % выбирается другой интервал
else
    ok = 0;             % иначе значение утверждается
    ansv;
end
end

%% Построение  графика распределения
interv = TDown:h:TUp;   % Вектор границ интервалов
figure(3);
hold on;
plot(interv, linspace(0, 0, hn+1),'k.', 'MarkerSize',10);
axis([TDown TUp 0 10]);

for (i = 1:1:hn) % Построение линий границ интервалов
    line([interv(i) interv(i)],[0 10]);
end
line([interv(hn)+h interv(hn)+h],[0 10]);

for (i = 1:1:hn) % Построение столбцов распределения
    line([(interv(i)+(0.5*h)) (interv(i)+(0.5*h))],[0 hs(i)], 'LineWidth',5, 'color', 'red');
end

title('Распределение значений перода по интервалам');
xlabel('Время, с.');
ylabel('Количество значений');

dfr = abs(fr-ansv);
bfr = dfr/fr * 100;

%% Вывод результатов

disp('Результаты имитационного моделирования:');
disp('------------------------------------------------------------------------');
disp(['Амплитуда сигнала:                            ' num2str(A)   ' усл. ед.']);
disp(['Фаза сигнала:                                 ' num2str(phi) ' рад.']);
disp(['Время наблюдения:                             ' num2str(t)   ' сек.']);
disp(['Количество полных колебаний:                  ' num2str(NTf)  ' шт.']);
disp(['Количество генерируемых помех:                ' num2str(np)  ' шт.']);
disp(['Частотца дискретизации сигнала:               ' num2str(fd)  ' Гц.']);
disp(['Размер окна поиска хар. точек:                ' num2str(n)   ' отс.']);
disp(['Количество интервалов разбиения:              ' num2str(hn)  ' шт.']);
disp('-------------------------------------------------------------------------');
disp(['ЧСС, измеренная в предыдущем цикле измерений: ' num2str(mem)  ' уд/сек.']);
disp(['ЧСС, заданная для обработки:                  ' num2str(fr)   ' уд/сек.']);
disp(['ЧСС полученная в рез. обработки данных:       ' num2str(ansv) ' уд/сек.']);
disp(['Абсолютная ошибка обработки данных:           ' num2str(dfr)  ' уд/сек.']);
disp(['Относительная ошибка обработки данных:        ' num2str(bfr)  ' %.']);
disp('-------------------------------------------------------------------------');





