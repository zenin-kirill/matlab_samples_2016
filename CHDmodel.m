%Программа имитационного моделирования алгоритма обработки данных ЧСС

clear all;
close all;
clc;

%% Основные параметры сигнала

mem = 13;        % Данные, измеренные в предыдущем цикле измерений
fr  = 15;        % Частота дыхания, уд/мин
A   = 1000;      % Амплитуда сигнала, усл. ед.
phi = 0;         % Фаза сигнала, рад.
t   = 50;        % Время наблюдения, сек.
fd  = 20;        % Частотца дискретизации сигнала, Гц
np  = 0;         % Количество помех, накладываемых на сигнал

f  = fr / 60;       % Перевод частоты в герцы 
f2 = f*6;           % ЧСС накладываемая на ЧД
Tf  = 1/f;          % Период полезных колебаний
NTf = fix(t/Tf);    % Полных перодов за 
Td = 1/fd;          % Период дискретизации
NT = fix(t / Td);   % Количество целых периодов дискретизации за время t
tn = Td * (0 : NT); % Вектор времени (сек), дискретизированный
                    % в соответствии с частотой дисретизации

%% Различне методы моделирования реального сигнала ЧСС

% Вектор значений сигнала чистой синусоиды (имитация сердечных сокращений)
%ynn = (A*sin(2*pi*f*tn+phi))+ (A * 1.5);  

% Вектор значений сигнала наложенных синусоид (имитация сердечных сокращений
% и процесса дыхания)

ynn = (A*sin(2*pi*f*tn+phi))+ (A/4*sin(2*pi*f+2*tn+phi)) + (A * 2) + (A/2.5*sin(2*pi*f2*tn+phi));

% Алгоритм, добавляющий в приближенный сигнал случайным образом
% множество "артефактов" различного характера и длительности
% (имитация процесса измерений в экстримальных условиях)


for i=1:1:np
    n = 5 + randi(NT-5);               % выбор случайного момента времени 
    d = (rand - 0.5) * randi(20000);   % генерация хаарктера и величины помехи
    ynn(n) = ynn(n) + d;                 % добавление помехи точку
    if (round(rand))                   % генерация длительности помехи 
        ynn(n-1) = ynn(n-1) + (rand * d);
        if (round(rand))
            ynn(n-2) = ynn(n-2) + (rand * d);
            if (round(rand))
                ynn(n-3) = ynn(n-3) + (rand * d/2);
                ynn(n-4) = ynn(n-4) + (rand * d/2);
            end
        end
    end
    if (round(rand))                   % генерация длительности помехи
        ynn(n+1) = ynn(n+1) + (rand * d);
        if (round(rand))
            ynn(n+2) = ynn(n+2) + (rand * d);
            if (round(rand))
                ynn(n+3) = ynn(n+3) + (rand * d/2);
                ynn(n+4) = ynn(n+4) + (rand * d/2);
            end
        end
    end
    
end
k = size(ynn);      % Длина реализацияя

for (i = 1:1:k(2))
    if (ynn(i)<0)
        ynn(i) = 0;
    end
    if (ynn(i)>4096)
        ynn(i) = 4096;
    end
end

% Алгоритм сглаживания

n = 24;
kn(2) = k(2) - n;

%yn2(1) = ynn(1); 
%yn2(2) = ynn(2); 
%for (i = 3:1:k(2))
%    if (abs(ynn(i)-ynn(i-1)) > (ynn(i-1)/2))
%        yn2(i) = ((ynn(i) + ynn(i-1)) + ynn(i-2))/3;
%    end
%end

for (i = 1:1:kn(2))
    sum = 0;
    for (j = 1:1:n)
        sum = sum + ynn(n+i-j);
    end
    yn(i) = (1/n)*sum;
end

tnn = Td * (0 : NT-n);

figure(1);         % Построение графика прилиженного сигнала
hold on;
title('Приближенный сигнал ЧД, под влиянием помех');
xlabel('Время, с.');
ylabel('Сигнал');
plot(tn,ynn,'k-');
axis([0 t 0 4096]);

figure(2);         % Построение графика разбора хар. точек
hold on;
title('Фильтрация сигнала, поиск минимумов');
xlabel('Время, с.');
ylabel('Сигнал');
plot(tnn,yn,'k-');
axis([0 t 0 4096]);

%% Разбор характерных точек

Nmins = 0;  % Счетчик минимумов
mins(:,1) = 0;  % Двумерный массив минимумов
mins(:,2) = 0;  % 1 - минмумы, 2 - номера значений
    
    for (i = 1+3:1:kn(2)-3)
       % Поиск минимумов
           if ((yn(i) < yn(i+1)) && (yn(i) <= yn(i-1))) 
               if ((yn(i) < yn(i+3)) && (yn(i) <= yn(i-3)))
                   if ((yn(i) < yn(i+3)) && (yn(i) <= yn(i-3)))
                        Nmins = Nmins + 1;
                        mins(Nmins,1) = yn(i);
                        mins(Nmins,2) = (i-1) * Td;
                   end
               end
           end
    end

% Отрисовка маркеров минимумов
plot(mins(:,2), mins(:,1),'r*');

Nper = Nmins-1;

periods(:,1) = 0;
periods(:,2) = 0;

% Нахождение значений периода
for i = 1:1:Nper
    periods(i,1) = mins(i+1,2) - mins(i,2);
end

%% Выбор наиболее вероятного периода

hn = 10; % Количество интервалов
hs(:,1) = linspace(0, 0, hn); % Количество величин
hs(:,2) = linspace(0, 0, hn); % в каждом интервале

TDown = min(periods(:,1));  % Нижняя граница значений периодов
TUp = max(periods(:,1));    % Верхняя граница значений периодов

h = (TUp - TDown) / hn;     % Размер интервала

for (i = 1:1:Nper)          % Распределение значений периодов по
    for (j = 1:1:hn)        % интервалам
        if (periods(i,1) < (TDown + (j*h)))
            hs(j,1) = hs(j,1) + 1;
            periods(i,2) = j;
            break
        end
    end
end


ok = 1;
while (ok ~= 0)

maxHS = 1;
for (i = 1:1:hn) % Выбор интервала с наибольшим количеством значений
    if (hs(maxHS,2) == 1)
        if (hs(i,2) == 0)
            maxHS = i;
        end
    else
    if (hs(i,1) > hs(maxHS,1) && hs(i,2)==0)
        maxHS = i;
    end
    end
end

if (hs(maxHS,1) == 0)
    ansv = NAN;
    break;
end

SA = 0;
n0 = 0;

for (i = 1:1:Nper) % Усреднение
    if (periods(i,2) == maxHS)
        n0 = n0 + 1;
        SA = SA + periods(i,1);
    end
end
SA = SA / n0;
ansv = (1/SA)*60;   % Расчет и валидация результата
if ((ansv > 60) || (ansv < 5) || (abs(ansv-mem)>= (mem/2)))
    ok = 1;             % Если значение неправдоподобно
    hs(maxHS,2) = 1;    % выбирается другой интервал
else
    ok = 0;             % иначе значение утверждается
    ansv;
end
end

%% Построение  графика распределения
interv = TDown:h:TUp;   % Вектор границ интервалов
figure(3);
plot(interv, linspace(0, 0, hn+1),'k.', 'MarkerSize',10);
axis([TDown TUp 0 10]);

for (i = 1:1:hn) % Построение линий границ интервалов
    line([interv(i) interv(i)],[0 10]);
end
line([interv(hn)+h interv(hn)+h],[0 10]);

for (i = 1:1:hn) % Построение столбцов распределения
    line([(interv(i)+(0.5*h)) (interv(i)+(0.5*h))],[0 hs(i)], 'LineWidth',5, 'color', 'red');
end

title('Распределение значений перода по интервалам');
xlabel('Время, с.');
ylabel('Количество значений');
hold on;

dfr = abs(fr-ansv);
bfr = dfr/fr * 100;

%% Вывод результатов

disp('Результаты имитационного моделирования:');
disp('------------------------------------------------------------------------');
disp(['Амплитуда сигнала:                            ' num2str(A)    ' усл. ед.']);
disp(['Фаза сигнала:                                 ' num2str(phi)  ' рад.']);
disp(['Время наблюдения:                             ' num2str(t)    ' сек.']);
disp(['Частота дискретизации сигнала:               ' num2str(fd)    ' Гц.']);
disp(['Количество полных колебаний:                  ' num2str(NTf)  ' шт.']);
disp(['Количество генерируемых помех:                ' num2str(np)   ' шт.']);
disp(['Длина окна фильтрации:                        ' num2str(n)    ' отс.']);
disp(['Количество интервалов разбиения:              ' num2str(hn)   ' шт.']);
disp('-------------------------------------------------------------------------');
disp(['ЧД, измеренная в предыдущем цикле измерений:  ' num2str(mem)  ' вд/сек.']);
disp(['ЧД, заданная для обработки:                   ' num2str(fr)   ' вд/сек.']);
disp(['ЧД полученная в рез. обработки данных:        ' num2str(ansv) ' вд/сек.']);
disp(['Абсолютная ошибка обработки данных:           ' num2str(dfr)  ' вд/сек.']);
disp(['Относительная ошибка обработки данных:        ' num2str(bfr)  ' %.']);
disp('-------------------------------------------------------------------------');





